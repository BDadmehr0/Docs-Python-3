# 3. آشنایی غیررسمی با پایتون

در مثال‌های زیر، ورودی و خروجی با حضور یا عدم حضور اعلان‌ها ([>>>](https://docs.python.org/3/glossary.html#term-0) و [...](https://docs.python.org/3/glossary.html#term-...)) متمایز می‌شوند: برای تکرار مثال، باید همه چیز را بعد از اعلان، زمانی که اعلان ظاهر می‌شود، تایپ کنید؛ خطوطی که با اعلان شروع نمی‌شوند، خروجی از مفسر هستند. توجه داشته باشید که اگر یک اعلان ثانویه به تنهایی در خطی در مثالی ظاهر شود، به این معنی است که باید یک خط خالی تایپ کنید؛ این برای پایان دادن به یک دستور چندخطی استفاده می‌شود.

می‌توانید نمایش اعلان‌ها و خروجی‌ها را با کلیک بر روی `>>>` در گوشه بالا-راست جعبه مثال، فعال یا غیرفعال کنید. اگر اعلان‌ها و خروجی‌های یک مثال را مخفی کنید، می‌توانید به‌راحتی خطوط ورودی را کپی کرده و در مفسر خود پیست کنید.

بسیاری از مثال‌های این راهنما، حتی آنهایی که در اعلان تعاملی وارد می‌شوند، شامل توضیحات (کامنت) هستند. در پایتون، توضیحات با کاراکتر هش `#` شروع می‌شوند و تا پایان خط فیزیکی ادامه می‌یابند. توضیح می‌تواند در ابتدای یک خط، بعد از فاصله یا کد ظاهر شود، اما نه در داخل یک رشته (استرینگ)؛ کاراکتر هش درون یک رشته فقط یک کاراکتر هش است. از آنجایی که توضیحات برای روشن کردن کد هستند و توسط پایتون تفسیر نمی‌شوند، می‌توان آنها را هنگام تایپ مثال‌ها حذف کرد.

چند مثال:

``` python
# this is the first comment
spam = 1  # and this is the second comment
          # ... and now a third!
text = "# This is not a comment because it's inside quotes."
```

## 3.1. استفاده از پایتون به عنوان ماشین حساب

بیایید چند دستور ساده پایتون را امتحان کنیم. مفسر را راه‌اندازی کنید و منتظر اعلان اولیه (>>>‌) باشید. (نباید زیاد طول بکشد.)

### 3.1.1. اعداد

مفسر مانند یک ماشین حساب ساده عمل می‌کند: می‌توانید یک عبارت را در آن تایپ کنید و مفسر مقدار آن را نمایش می‌دهد. نحو (سینتکس) عبارات ساده است: از عملگرهای `+`، `-`، `*` و `/` می‌توان برای انجام عملیات ریاضی استفاده کرد؛ پرانتزها (`()`) نیز برای گروه‌بندی به‌کار می‌روند. مثلا:

``` python
>>> 2 + 2
4
>>> 50 - 5*6
20
>>> (50 - 5*6) / 4
5.0
>>> 8 / 5  # تقسیم همیشه یک عدد ممیز شناور(اعشاری - float) را برمی گرداند
1.6
```
اعداد صحیح (به عنوان مثال `2`، `4`، `20`) دارای نوع [int](https://docs.python.org/3/library/functions.html#int) هستند، آنهایی که دارای قسمت کسری هستند (به عنوان مثال `5.0`، `1.6`) دارای نوع [float](https://docs.python.org/3/library/functions.html#float) هستند. در ادامه آموزش اطلاعات بیشتری در مورد انواع عددی خواهیم دید.


تقسیم (`/`) همیشه یک عدد اعشاری را برمی‌گرداند. برای انجام تقسیم طبقه و به دست آوردن نتیجه عدد صحیح می توانید از عملگر `//` استفاده کنید. برای محاسبه باقی مانده می توانید از `%` استفاده کنید:

``` python
>>> 17 / 3  # classic division returns a float
5.666666666666667
>>> 17 // 3  # floor division discards the fractional part
5
>>> 17 % 3  # the % operator returns the remainder of the division
2
>>> 5 * 3 + 2  # floored quotient * divisor + remainder
17
```

با پایتون، می توان از عملگر ** برای محاسبه توان ها استفاده کرد [^1]:

``` python
>>> 5 ** 2  # 5 squared
25
>>> 2 ** 7  # 2 to the power of 7
128
```

علامت مساوی (`=`) برای اختصاص دادن یک مقدار به یک متغیر استفاده می‌شود. پس از آن، هیچ نتیجه‌ای قبل از نمایش اعلان تعاملی بعدی نشان داده نمی‌شود.

``` python
>>> width = 20
>>> height = 5 * 9
>>> width * height
900
```

اگر یک متغیر "تعریف" نشده باشد (مقداری به آن اختصاص داده نشده باشد)، تلاش برای استفاده از آن باعث بروز خطا می‌شود.

``` python
>>> n  # try to access an undefined variable
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
```

پشتیبانی کامل از اعداد اعشاری وجود دارد؛ عملگرهایی که با عملوندهای مختلط (عدد صحیح و اعشاری) کار می‌کنند، عملوند عدد صحیح را به عدد اعشاری تبدیل می‌کنند.

``` python
>>> 4 * 3.75 - 1
14.0
```

در حالت تعاملی، آخرین عبارت چاپ‌شده به متغیر `_` اختصاص داده می‌شود. این به این معناست که وقتی از پایتون به عنوان یک ماشین حساب رومیزی استفاده می‌کنید، ادامه دادن محاسبات تا حدودی آسان‌تر است. برای مثال:

``` python
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
```

این متغیر باید توسط کاربر به‌عنوان فقط خواندنی در نظر گرفته شود. به‌طور صریح مقداری به آن اختصاص ندهید—این کار یک متغیر محلی مستقل با همان نام ایجاد می‌کند که رفتار جادویی متغیر داخلی را مخفی می‌کند.

علاوه بر [int](https://docs.python.org/3/library/functions.html#int) و [float](https://docs.python.org/3/library/functions.html#float)، پایتون از انواع دیگری از اعداد مانند [Decimal](https://docs.python.org/3/library/decimal.html#decimal.Decimal) و [Fraction](https://docs.python.org/3/library/fractions.html#fractions.Fraction) نیز پشتیبانی می‌کند. پایتون همچنین پشتیبانی داخلی از [اعداد مختلط (complex)](https://docs.python.org/3/library/stdtypes.html#typesnumeric) دارد و از پسوند `j` یا `J` برای نشان دادن بخش موهومی استفاده می‌کند (مثلاً `3+5j`).

### 3.1.2. متن

پایتون می‌تواند متون (که با نوع [str](https://docs.python.org/3/library/stdtypes.html#str) نمایش داده می‌شوند و به آن‌ها «رشته» گفته می‌شود) را همانند اعداد مدیریت کند. این شامل کاراکترهایی مانند "`!`"، کلماتی مانند "`rabbit`"، نام‌هایی مانند "`Paris`"، جملاتی مانند "`Got your back.`" و غیره، همچنین "`Yay! :)`". این متون می‌توانند درون گیومه‌های تکی (`'...'`) یا گیومه‌های دوتایی (`"..."`) قرار گیرند و نتیجه یکسانی داشته باشند.

``` python
>>> 'spam eggs'  # single quotes
'spam eggs'
>>> "Paris rabbit got your back :)! Yay!"  # double quotes
'Paris rabbit got your back :)! Yay!'
>>> '1975'  # digits and numerals enclosed in quotes are also strings
'1975'
```

برای نقل قول درون یک نقل قول، باید آن را با یک `\` "فاصله" دهیم (escape)، یعنی قبل از آن \ قرار دهیم. به‌طور جایگزین، می‌توانیم از نوع دیگر علامت نقل قول استفاده کنیم.

``` python
>>> 'doesn\'t'  # use \' to escape the single quote...
"doesn't"
>>> "doesn't"  # ...or use double quotes instead
"doesn't"
>>> '"Yes," they said.'
'"Yes," they said.'
>>> "\"Yes,\" they said."
'"Yes," they said.'
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
```

در شل پایتون، تعریف رشته و خروجی رشته می‌تواند متفاوت به نظر برسد. تابع `print()` خروجی قابل‌خواندنی‌تری تولید می‌کند، با حذف گیومه‌های دور رشته و چاپ کاراکترهای فرار و کاراکترهای ویژه.
``` python
>>> s = 'First line.\nSecond line.'  # \n means newline
>>> s  # without print(), special characters are included in the string
'First line.\nSecond line.'
>>> print(s)  # with print(), special characters are interpreted, so \n produces new line
First line.
Second line.
```

اگر نمی‌خواهید کاراکترهایی که با `\` آغاز می‌شوند به‌عنوان کاراکترهای ویژه تفسیر شوند، می‌توانید از رشته‌های خام استفاده کنید و با افزودن `r` قبل از اولین گیومه این کار را انجام دهید:

``` python
>>> print('C:\some\name')  # here \n means newline!
C:\some
ame
>>> print(r'C:\some\name')  # note the r before the quote
C:\some\name
```

یک جنبه ظریف در رشته‌های خام وجود دارد: یک رشته خام نمی‌تواند با یک تعداد فرد از کاراکترهای `\` خاتمه یابد؛ برای اطلاعات بیشتر و راه‌حل‌ها به بخش [پرسش‌های متداول](https://docs.python.org/3/faq/programming.html#faq-programming-raw-string-backslash) مراجعه کنید.

لیترال‌های رشته‌ای می‌توانند شامل چندین خط باشند. یکی از روش‌ها استفاده از گیومه‌های سه‌گانه است: `"""..."""` یا `'''...'''`. پایان خط‌ها به‌طور خودکار در رشته گنجانده می‌شوند، اما می‌توان با افزودن یک `\` در انتهای خط، از این کار جلوگیری کرد. در مثال زیر، خط جدید اولیه شامل نمی‌شود:


``` python
>>> print("""\
... Usage: thingy [OPTIONS]
...      -h                        Display this usage message
...      -H hostname               Hostname to connect to
... """)
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
```

رشته‌ها می‌توانند با عملگر `+` به هم متصل (چسبانده) شوند و با `*` تکرار شوند:

``` python
>>> # 3 times 'un', followed by 'ium'
>>> 3 * 'un' + 'ium'
'unununium'
```

دو یا چند لیترال رشته‌ای (یعنی آن‌هایی که بین گیومه‌ها قرار دارند) که در کنار یکدیگر قرار دارند، به‌طور خودکار به هم متصل می‌شوند.

``` python
>>> 'Py' 'thon'
'Python'
```

این ویژگی به‌ویژه زمانی مفید است که بخواهید رشته‌های طولانی را بشکنید:

``` python
>>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
```

این تنها با دو لیترال کار می‌کند، نه با متغیرها یا عبارات:

``` python
>>> prefix = 'Py'
>>> prefix 'thon'  # can't concatenate a variable and a string literal
  File "<stdin>", line 1
    prefix 'thon'
           ^^^^^^
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  File "<stdin>", line 1
    ('un' * 3) 'ium'
               ^^^^^
SyntaxError: invalid syntax
```

اگر می‌خواهید متغیرها یا یک متغیر و یک لیترال را به هم متصل کنید، از ‍`+` استفاده کنید:

``` python
>>> prefix + 'thon'
'Python'
```

رشته‌ها می‌توانند ایندکس‌گذاری (زیرنویس‌گذاری) شوند، به‌طوری که اولین کاراکتر دارای ایندکس 0 باشد. نوع جداگانه‌ای برای کاراکتر وجود ندارد؛ یک کاراکتر در واقع یک رشته با اندازه یک است:

``` python
>>> word = 'Python'
>>> word[0]  # character in position 0
'P'
>>> word[5]  # character in position 5
'n'
```

ایندکس‌ها همچنین می‌توانند اعداد منفی باشند تا شمارش از سمت راست آغاز شود:

``` python
>>> word[-1]  # last character
'n'
>>> word[-2]  # second-last character
'o'
>>> word[-6]
'P'
```

توجه داشته باشید که از آنجایی که -0 با 0 برابر است، ایندکس‌های منفی از -1 آغاز می‌شوند.

علاوه بر ایندکس‌گذاری، برش (slicing) نیز پشتیبانی می‌شود. در حالی که ایندکس‌گذاری برای به‌دست‌آوردن کاراکترهای فردی استفاده می‌شود، برش به شما این امکان را می‌دهد که یک زیررشته (substring) به‌دست آورید:

``` python
>>> word[0:2]  # characters from position 0 (included) to 2 (excluded)
'Py'
>>> word[2:5]  # characters from position 2 (included) to 5 (excluded)
'tho'
```

ایندکس‌های برش دارای مقادیر پیش‌فرض مفیدی هستند؛ اگر ایندکس اول حذف شود، به‌طور پیش‌فرض به صفر تنظیم می‌شود و اگر ایندکس دوم حذف شود، به اندازه رشته‌ای که برش می‌خورد تنظیم می‌شود.

``` python
>>> word[:2]   # character from the beginning to position 2 (excluded)
'Py'
>>> word[4:]   # characters from position 4 (included) to the end
'on'
>>> word[-2:]  # characters from the second-last (included) to the end
'on'
```

توجه داشته باشید که شروع همیشه شامل می‌شود و انتها همیشه مستثنی است. این اطمینان حاصل می‌کند که `s[:i] + s[i:]` همیشه برابر با `s` است:+

``` python
>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
```

یکی از راه‌های به خاطر سپردن نحوه کار برش‌ها این است که به ایندکس‌ها به‌عنوان اشاره‌گرهایی بین کاراکترها فکر کنید، به‌طوری که لبه چپ اولین کاراکتر شماره 0 داشته باشد. سپس لبه راست آخرین کاراکتر یک رشته با n کاراکتر، ایندکس n را دارد. برای مثال:

``` python
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
```

ردیف اول اعداد، موقعیت ایندکس‌های 0…6 در رشته را نشان می‌دهد؛ ردیف دوم ایندکس‌های منفی متناظر را می‌دهد. برش از i تا j شامل تمام کاراکترهای بین لبه‌های مشخص‌شده با i و j به ترتیب است.

برای ایندکس‌های غیرمنفی، طول یک برش برابر با تفاوت ایندکس‌هاست، به شرطی که هر دو در محدوده مجاز باشند. برای مثال، طول `word[1:3]` برابر با 2 است.

تلاش برای استفاده از ایندکسی که بیش از حد بزرگ است، منجر به بروز خطا خواهد شد:

``` python
>>> word[42]  # the word only has 6 characters
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
```

با این حال، ایندکس‌های برش خارج از محدوده به‌خوبی مدیریت می‌شوند وقتی برای برش استفاده شوند:

``` python
>>> word[4:42]
'on'
>>> word[42:]
''
```

رشته‌های پایتون قابل تغییر نیستند — آن‌ها غیرقابل تغییر [immutable](https://docs.python.org/3/glossary.html#term-immutable) هستند. بنابراین، اختصاص دادن مقداری به یک موقعیت ایندکس‌شده در رشته منجر به بروز خطا می‌شود:

``` python
>>> word[0] = 'J'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

اگر به یک رشته متفاوت نیاز دارید، باید یک رشته جدید ایجاد کنید:

``` python
>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
```

تابع داخلی `len()` طول یک رشته را برمی‌گرداند:

``` python
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
```

**همچنین ببینید**

- [نوع دنباله متن — str](../library/stdtypes.html#textseq): 
  رشته‌ها نمونه‌هایی از *نوع‌های دنباله‌ای* هستند و عملیات‌های مشترکی که توسط این نوع‌ها پشتیبانی می‌شوند را پشتیبانی می‌کنند.

- [روش‌های رشته](../library/stdtypes.html#string-methods): 
  رشته‌ها از تعداد زیادی روش برای تبدیل‌های پایه و جستجو پشتیبانی می‌کنند.

- [اف-استرینگ (f-strings)](../reference/lexical_analysis.html#f-strings): 
  ادبیات رشته‌ای که شامل عبارات تو در تو است.

- [نحو فرمت رشته](../library/string.html#formatstrings): 
  اطلاعاتی درباره فرمت‌بندی رشته با استفاده از [`str.format()`](../library/stdtypes.html#str.format).

- [فرمت‌بندی رشته به سبک printf](../library/stdtypes.html#old-string-formatting): 
  عملیات‌های فرمت‌بندی قدیمی که زمانی که رشته‌ها عملوند چپ اپراتور `%` هستند فراخوانی می‌شوند، در اینجا به تفصیل توضیح داده شده است.


### 3.1.3. لیست

پایتون چندین نوع داده مرکب را می‌شناسد که برای گروه‌بندی مقادیر دیگر استفاده می‌شوند. متنوع‌ترین نوع آن لیست است که می‌توان آن را به‌صورت فهرستی از مقادیر جداشده با کاما (آیتم‌ها) بین کروشه نوشت. لیست‌ها ممکن است آیتم‌هایی از انواع مختلف را شامل شوند، اما معمولاً همه آیتم‌ها از یک نوع هستند.

``` python
>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
```

مانند رشته‌ها (و تمامی انواع دنباله‌های توکار دیگر)، لیست‌ها نیز قابل اندیس‌گذاری و برش هستند:

``` python
>>> squares[0]  # indexing returns the item
1
>>> squares[-1]
25
>>> squares[-3:]  # slicing returns a new list
[9, 16, 25]
```

لیست‌ها همچنین از عملگرهایی مانند الحاق (ترکیب) پشتیبانی می‌کنند:

``` python
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

برخلاف رشته‌ها که تغییرناپذیر ([immutable](https://docs.python.org/3/glossary.html#term-immutable)) هستند، لیست‌ها نوعی قابل‌تغییر ([mutable](https://docs.python.org/3/glossary.html#term-mutable)) هستند، به این معنا که امکان تغییر محتوای آن‌ها وجود دارد:

``` python
>>> cubes = [1, 8, 27, 65, 125]  # something's wrong here
>>> 4 ** 3  # the cube of 4 is 64, not 65!
64
>>> cubes[3] = 64  # replace the wrong value
>>> cubes
[1, 8, 27, 64, 125]
```

همچنین می‌توانید با استفاده از متد `list.append()` آیتم‌های جدیدی را به انتهای لیست اضافه کنید (بعداً بیشتر درباره متدها صحبت خواهیم کرد):

``` python
>>> cubes.append(216)  # add the cube of 6
>>> cubes.append(7 ** 3)  # and the cube of 7
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
```

در پایتون، انتساب ساده هرگز داده‌ها را کپی نمی‌کند. وقتی یک لیست را به یک متغیر اختصاص می‌دهید، آن متغیر به لیست موجود اشاره می‌کند. هر تغییری که از طریق یک متغیر روی لیست اعمال کنید، از طریق همه متغیرهای دیگری که به آن لیست اشاره می‌کنند، قابل مشاهده خواهد بود.

``` python
>>> rgb = ["Red", "Green", "Blue"]
>>> rgba = rgb
>>> id(rgb) == id(rgba)  # they reference the same object
True
>>> rgba.append("Alph")
>>> rgb
["Red", "Green", "Blue", "Alph"]
```

تمام عملیات برش (slicing) یک لیست جدید حاوی عناصر درخواست‌شده را برمی‌گردانند. این بدان معناست که برش زیر یک کپی سطحی ([shallow copy](https://docs.python.org/3/library/copy.html#shallow-vs-deep-copy)) از لیست را برمی‌گرداند:

``` python
>>> correct_rgba = rgba[:]
>>> correct_rgba[-1] = "Alpha"
>>> correct_rgba
["Red", "Green", "Blue", "Alpha"]
>>> rgba
["Red", "Green", "Blue", "Alph"]
```

اختصاص دادن به برش‌ها نیز ممکن است، و این کار حتی می‌تواند اندازه لیست را تغییر دهد یا آن را به‌طور کامل خالی کند:

``` python
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # replace some values
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # now remove them
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # clear the list by replacing all the elements with an empty list
>>> letters[:] = []
>>> letters
[]
```

تابع داخلی `len()` همچنین برای لیست‌ها قابل استفاده است:

``` python
>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
```

امکان تو در تو کردن لیست‌ها (ایجاد لیست‌هایی که شامل لیست‌های دیگر هستند) وجود دارد، برای مثال:

``` python
>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'
```

## 3.2. اولین قدم‌ها به‌سوی برنامه‌نویسی

البته، می‌توانیم از پایتون برای انجام وظایف پیچیده‌تر از جمع کردن دو و دو استفاده کنیم. به عنوان مثال، می‌توانیم یک زیررشته ابتدایی از دنباله فیبوناچی را به صورت زیر بنویسیم:

``` python
>>> # Fibonacci series:
>>> # the sum of two elements defines the next
>>> a, b = 0, 1
>>> while a < 10:
...     print(a)
...     a, b = b, a+b
... 
0
1
1
2
3
5
8
```

این مثال چند ویژگی جدید را معرفی می‌کند.

- **اختصاص چندگانه**: خط اول شامل یک اختصاص چندگانه است: متغیرهای `a` و `b` به‌طور همزمان مقادیر جدید 0 و 1 را دریافت می‌کنند. در خط آخر این دوباره استفاده می‌شود، و نشان می‌دهد که عبارات در سمت راست ابتدا همه ارزیابی می‌شوند قبل از اینکه هیچ‌یک از انتساب‌ها انجام شود. عبارات سمت راست از چپ به راست ارزیابی می‌شوند.

- **حلقه while**: حلقه [while](https://docs.python.org/3/reference/compound_stmts.html#while) تا زمانی که شرط (در اینجا: `a < 10`) درست باقی بماند اجرا می‌شود. در پایتون، مانند زبان C، هر مقدار صحیح غیرصفر درست است؛ صفر نادرست است. شرط ممکن است یک رشته یا مقدار لیست باشد، در واقع هر توالی؛ هر چیزی با طول غیرصفر درست است و توالی‌های خالی نادرست هستند. تست استفاده‌شده در این مثال یک مقایسه ساده است. اپراتورهای مقایسه استاندارد به همان صورت که در C نوشته می‌شوند: `<` (کمتر از)، `>` (بیشتر از)، `==` (برابر با)، `<=` (کمتر یا برابر با)، `>=` (بیشتر یا برابر با) و `!=` (نابرابر با).

- **بدنه حلقه**: بدنه حلقه تو رفتگی دارد: تو رفتگی روش پایتون برای گروه‌بندی دستورات است. در پرامپت تعاملی، شما باید برای هر خط تو رفته یک تب یا فاصله (space) وارد کنید. در عمل، شما ورودی‌های پیچیده‌تری برای پایتون با یک ویرایشگر متن آماده خواهید کرد؛ همه ویرایشگرهای متن خوب دارای قابلیت خودکار کردن تو رفتگی هستند. وقتی یک دستور ترکیبی به‌طور تعاملی وارد می‌شود، باید با یک خط خالی به پایان برسد تا نشان‌دهنده اتمام آن باشد (زیرا تحلیل‌گر نمی‌تواند حدس بزند که شما آخرین خط را وارد کرده‌اید). توجه داشته باشید که هر خط درون یک بلوک پایه باید به یک میزان تو رفته باشد.

- **تابع print()**: تابع [print()](https://docs.python.org/3/library/functions.html#print) مقدار آرگومان(ها)ی داده شده را می‌نویسد. این تابع از نوشتن صرفاً بیانیه‌ای که می‌خواهید بنویسید (همانطور که در مثال‌های ماشین حساب انجام دادیم) در نحوه مدیریت آرگومان‌های متعدد، مقادیر شناور، و رشته‌ها متفاوت است. رشته‌ها بدون کوتیشن چاپ می‌شوند و یک فاصله بین آیتم‌ها وارد می‌شود، بنابراین می‌توانید چیزها را به‌خوبی قالب‌بندی کنید، مانند این:

``` python
>>> i = 256*256
>>> print('The value of i is', i)
The value of i is 65536
```

آرگومان کلیدی `end` می‌تواند برای جلوگیری از ایجاد خط جدید بعد از خروجی استفاده شود، یا می‌تواند خروجی را با یک رشته متفاوت به پایان برساند:

``` python
>>> a, b = 0, 1
>>> while a < 1000:
...     print(a, end=',')
...     a, b = b, a+b
...
0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
```

### پانویس‌ها

[^1] از آنجا که `**` اولویت بالاتری نسبت به `-` دارد، `-3**2` به عنوان `-(3**2)` تفسیر می‌شود و در نتیجه به `-9` منجر می‌شود. برای جلوگیری از این موضوع و دریافت `9`، می‌توانید از `(-3)**2` استفاده کنید.

[^2] بر خلاف سایر زبان‌ها، کاراکترهای ویژه‌ای مانند `\n` با هر دو نوع کوتیشن (تک `'...'` و دوگانه `"..."`) دارای همان معنی هستند. تنها تفاوت بین این دو این است که در کوتیشن‌های تک نیازی به فرار دادن `"` نیست (اما باید `\` را فرار دهید) و برعکس.
