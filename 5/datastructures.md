# 5. ساختارهای داده

این فصل برخی از چیزهایی که قبلاً یاد گرفته‌اید را با جزئیات بیشتری توضیح می‌دهد و همچنین موارد جدیدی را نیز اضافه می‌کند.

## 5.1. اطلاعات بیشتر در مورد لیست‌ها 

نوع داده لیست تعدادی متدهای بیشتری دارد. در اینجا تمام متدهای مربوط به اشیاء لیست آمده است:

**list.append(x)**  

یک آیتم را به انتهای لیست اضافه می‌کند. معادل است با `a[len(a):] = [x]`.

**list.extend(iterable)**  

لیست را با افزودن تمام آیتم‌های قابل پیمایش (iterable) گسترش می‌دهد. معادل است با `a[len(a):] = iterable`.

**list.insert(i, x)**  

یک آیتم را در موقعیت مشخص‌شده قرار می‌دهد. اولین آرگومان اندیس عنصری است که قبل از آن باید درج شود، بنابراین `a.insert(0, x)` آیتم را در ابتدای لیست درج می‌کند و `a.insert(len(a), x)` معادل با `a.append(x)` است.

**list.remove(x)**  

اولین آیتمی که مقدار آن برابر با x باشد را از لیست حذف می‌کند. اگر چنین آیتمی وجود نداشته باشد، خطای [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError) ایجاد می‌شود.

**list.pop([i])**  

آیتم موجود در موقعیت مشخص‌شده را از لیست حذف کرده و آن را برمی‌گرداند. اگر اندیسی مشخص نشود، `a.pop()` آخرین آیتم لیست را حذف کرده و برمی‌گرداند. اگر لیست خالی باشد یا اندیس خارج از محدوده باشد، خطای [IndexError](https://docs.python.org/3/library/exceptions.html#IndexError) رخ می‌دهد.

**list.clear()**  

همه آیتم‌های لیست را حذف می‌کند. معادل با `del a[:]`.

**list.index(x[, start[, end]])**  

اندیس اولین آیتمی که مقدار آن برابر با x باشد را بازمی‌گرداند. اگر چنین آیتمی وجود نداشته باشد، خطای [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError) رخ می‌دهد.

آرگومان‌های اختیاری `start` و `end` مشابه با نحو برش (slice notation) تفسیر می‌شوند و برای محدود کردن جستجو به زیرمجموعه‌ای از لیست استفاده می‌شوند. اندیس بازگشتی نسبت به ابتدای دنباله کامل محاسبه می‌شود و نه آرگومان `start`.

**list.count(x)**  

تعداد دفعاتی که x در لیست ظاهر شده را بازمی‌گرداند.

**list.sort(*, key=None, reverse=False)**  

آیتم‌های لیست را به صورت محلی مرتب می‌کند (آرگومان‌ها می‌توانند برای سفارشی‌سازی مرتب‌سازی استفاده شوند، برای توضیح آن‌ها به تابع [sorted()](https://docs.python.org/3/library/functions.html#sorted) مراجعه کنید).

**list.reverse()**  

عناصر لیست را به صورت محلی معکوس می‌کند.

**list.copy()**  

یک نسخه سطحی (shallow copy) از لیست را بازمی‌گرداند. معادل با `a[:]`.

مثالی که از اکثر متدهای لیست استفاده می کند:
``` python
>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
>>> fruits.count('apple')
2
>>> fruits.count('tangerine')
0
>>> fruits.index('banana')
3
>>> fruits.index('banana', 4)  # Find next banana starting at position 4
6
>>> fruits.reverse()
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
>>> fruits.append('grape')
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
>>> fruits.sort()
>>> fruits
['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
>>> fruits.pop()
'pear'
```

ممکن است متوجه شده باشید که متدهایی مانند `insert`، `remove` یا `sort` که فقط لیست را تغییر می‌دهند، هیچ مقدار بازگشتی چاپ نمی‌کنند – این متدها مقدار پیش‌فرض `None` را بازمی‌گردانند. [^1] این یک اصل طراحی برای تمام ساختارهای داده قابل تغییر (mutable) در پایتون است.

چیز دیگری که ممکن است متوجه شوید این است که همه داده‌ها قابل مرتب‌سازی یا مقایسه نیستند. به عنوان مثال، `[None, 'hello', 10]` قابل مرتب‌سازی نیست، زیرا اعداد صحیح قابل مقایسه با رشته‌ها نیستند و `None` نیز با دیگر نوع‌ها قابل مقایسه نیست. همچنین، برخی از نوع‌ها رابطه ترتیبی تعریف‌شده‌ای ندارند. به عنوان مثال، مقایسه `3+4j < 5+7j` معتبر نیست.

### 5.1.1. استفاده از لیست‌ها به‌عنوان پشته‌ها

متدهای لیست استفاده از لیست به عنوان یک پشته (stack) را بسیار آسان می‌کنند، جایی که آخرین عنصر اضافه شده اولین عنصری است که بازیابی می‌شود ("آخرین ورودی، اولین خروجی"). برای اضافه کردن یک آیتم به بالای پشته از `append()` استفاده کنید. برای بازیابی یک آیتم از بالای پشته، از `pop()` بدون مشخص کردن اندیس استفاده کنید. برای مثال:

``` python
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
```

### 5.1.2. استفاده از لیست‌ها به‌عنوان صف‌ها

همچنین می‌توان از لیست به عنوان یک صف (queue) استفاده کرد، جایی که اولین عنصر اضافه شده، اولین عنصری است که بازیابی می‌شود ("اولین ورودی، اولین خروجی"). با این حال، لیست‌ها برای این منظور کارآمد نیستند. در حالی که افزودن و حذف عناصر از انتهای لیست سریع است، انجام عملیات درج یا حذف از ابتدای لیست کند است (زیرا تمام عناصر دیگر باید به اندازه یک واحد جابه‌جا شوند).

برای پیاده‌سازی یک صف، از [collections.deque](https://docs.python.org/3/library/collections.html#collections.deque) استفاده کنید که برای افزودن و حذف سریع از هر دو طرف طراحی شده است. به عنوان مثال:

``` python
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry arrives
>>> queue.append("Graham")          # Graham arrives
>>> queue.popleft()                 # The first to arrive now leaves
'Eric'
>>> queue.popleft()                 # The second to arrive now leaves
'John'
>>> queue                           # Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])
```

### 5.1.3. درک لیست‌ها

تعبیرهای لیستی (List comprehensions) روشی مختصر برای ایجاد لیست‌ها ارائه می‌دهند. کاربردهای رایج آن‌ها شامل ایجاد لیست‌های جدید است که در آن هر عنصر نتیجه عملیاتی است که بر روی هر عضو از یک دنباله یا قابل پیمایش (iterable) دیگر اعمال شده است، یا ایجاد زیرمجموعه‌ای از عناصری که شرایط خاصی را برآورده می‌کنند.

به عنوان مثال، فرض کنید می‌خواهیم لیستی از مربعات اعداد ایجاد کنیم، مانند:

``` python
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

توجه داشته باشید که این کد یک متغیر به نام `x` ایجاد می‌کند (یا آن را بازنویسی می‌کند) که پس از اتمام حلقه هنوز وجود دارد. می‌توانیم لیست مربعات را بدون هیچ گونه اثر جانبی محاسبه کنیم با استفاده از:

``` python
squares = list(map(lambda x: x**2, range(10)))
```

یا به طور معادل:

``` python
squares = [x**2 for x in range(10)]
```

که این روش مختصرتر و خواناتر است.

یک تعبیر لیستی (list comprehension) شامل براکت‌هایی است که یک عبارت را در خود دارند و پس از آن یک جمله `for`، و سپس صفر یا چند جمله `for` یا `if` قرار می‌گیرد. نتیجه یک لیست جدید خواهد بود که از ارزیابی عبارت در زمینه جملات `for` و `if` که پس از آن آمده‌اند، به دست می‌آید. به عنوان مثال، این تعبیر لیستی (listcomp) عناصری از دو لیست را ترکیب می‌کند اگر آن‌ها برابر نباشند:

``` python
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

و معادل با:

``` python
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

به ترتیب جملات [for](https://docs.python.org/3/reference/compound_stmts.html#for) و [if](https://docs.python.org/3/reference/compound_stmts.html#if) در هر دو کد توجه کنید که یکسان است.

اگر عبارت یک زوج مرتب (tuple) باشد (به عنوان مثال، `(x, y)` در مثال قبلی)، باید در پرانتز قرار گیرد.

``` python
>>> vec = [-4, -2, 0, 2, 4]
>>> # create a new list with the values doubled
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # filter the list to exclude negative numbers
>>> [x for x in vec if x >= 0]
[0, 2, 4]
>>> # apply a function to all the elements
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>> # call a method on each element
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # create a list of 2-tuples like (number, square)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # the tuple must be parenthesized, otherwise an error is raised
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1
    [x, x**2 for x in range(6)]
     ^^^^^^^
SyntaxError: did you forget parentheses around the comprehension target?
>>> # flatten a list using a listcomp with two 'for'
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

تعبیرهای لیستی می‌توانند شامل عبارات پیچیده و توابع تو در تو باشند:

``` python
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```

### 5.1.4. درک لیست‌های تو در تو

عبارت اولیه در یک تعبیر لیستی می‌تواند هر عبارت دلخواهی باشد، از جمله یک تعبیر لیستی دیگر.

به مثال زیر از یک ماتریس ۳ در ۴ توجه کنید که به عنوان یک لیست از ۳ لیست با طول ۴ پیاده‌سازی شده است:

``` python
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
```

تعبیر لیستی زیر ردیف‌ها و ستون‌ها را جابجا (ترانهاده) می‌کند:

``` python
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

همان‌طور که در بخش قبلی مشاهده کردیم، تعبیر لیستی درونی در زمینه جملۀ [for](https://docs.python.org/3/reference/compound_stmts.html#for) که پس از آن آمده است، ارزیابی می‌شود، بنابراین این مثال معادل با:

``` python
>>> transposed = []
>>> for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

که به نوبه خود، معادل با:

``` python
>>> transposed = []
>>> for i in range(4):
...    # the following 3 lines implement the nested listcomp
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

در دنیای واقعی، باید به جای استفاده از عبارات کنترلی پیچیده، از توابع داخلی استفاده کنید. تابع [zip()](https://docs.python.org/3/library/functions.html#zip) برای این مورد بسیار مناسب است:

``` python
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```

برای جزئیات بیشتر در مورد ستاره (*) در این خط، به بخش "[Unpacking Argument Lists](https://docs.python.org/3/tutorial/controlflow.html#tut-unpacking-arguments)" مراجعه کنید.


### 5.2. عبارت del

راهی برای حذف یک آیتم از یک لیست با استفاده از **اندیس** آن، به جای مقدار آن وجود دارد: دستور [del](https://docs.python.org/3/reference/simple_stmts.html#del). این روش با متد `pop()` تفاوت دارد، چرا که `pop()` مقداری را بازمی‌گرداند. از دستور del همچنین می‌توان برای حذف چندین عنصر به صورت یک **بازه** از لیست یا پاک کردن کامل لیست استفاده کرد (که قبلاً این کار را با تخصیص یک لیست خالی به بازه انجام دادیم). برای مثال:

``` python
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
```

از دستور `del` همچنین می‌توان برای حذف کامل یک **متغیر** استفاده کرد :
``` python
>> del a
```

ارجاع به نام متغیر `a` پس از حذف آن، باعث ایجاد خطا می‌شود (حداقل تا زمانی که مقدار دیگری به آن اختصاص داده شود). در ادامه، کاربردهای دیگری برای دستور `del` خواهیم یافت.

## 5.3. تاپل‌ها و دنباله‌ها

دیدیم که لیست‌ها و رشته‌ها ویژگی‌های مشترک زیادی دارند، مانند عملیات اندیس‌گذاری و برش. این دو نمونه‌ای از انواع داده ترتیبی (Sequence) هستند ([به انواع ترتیبی — `list`، `tuple`، `range` مراجعه کنید](https://docs.python.org/3/library/stdtypes.html#typesseq)). از آنجا که پایتون یک زبان در حال توسعه است، ممکن است انواع داده ترتیبی دیگری نیز به آن اضافه شوند. همچنین یک نوع داده ترتیبی استاندارد دیگر به نام تاپل (tuple) وجود دارد.

یک تاپل شامل تعدادی مقدار است که با کاما از یکدیگر جدا شده‌اند، برای مثال:

``` python
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Tuples may be nested:
>>> u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
>>> t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
>>> v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
```

همان‌طور که می‌بینید، در خروجی تاپل‌ها همیشه درون پرانتز قرار می‌گیرند تا تاپل‌های تو در تو به درستی تفسیر شوند؛ هنگام ورود، می‌توان تاپل‌ها را با یا بدون پرانتز وارد کرد، اگرچه اغلب پرانتزها ضروری هستند (اگر تاپل بخشی از یک عبارت بزرگتر باشد). امکان اختصاص مقدار به عناصر منفرد یک تاپل وجود ندارد، با این حال، می‌توان تاپل‌هایی ساخت که شامل اشیاء قابل تغییر مانند لیست‌ها باشند.

اگرچه تاپل‌ها شبیه به لیست‌ها به نظر می‌رسند، اما اغلب در موقعیت‌ها و اهداف متفاوتی استفاده می‌شوند. تاپل‌ها تغییرناپذیر ([immutable](https://docs.python.org/3/glossary.html#term-immutable)) هستند و معمولاً شامل دنباله‌ای ناهمگن از عناصر هستند که از طریق **بسته‌بندی (unpacking)** یا **اندیس‌گذاری** (یا حتی از طریق ویژگی در صورت استفاده از [namedtupleها](https://docs.python.org/3/library/collections.html#collections.namedtuple)) دسترسی پیدا می‌کنند. از سوی دیگر، لیست‌ها تغییرپذیر ([mutable](https://docs.python.org/3/glossary.html#term-mutable)) هستند و معمولاً شامل عناصری همگن هستند که با تکرار در لیست به آن‌ها دسترسی پیدا می‌شود.

یک مشکل خاص، ساخت تاپل‌هایی با 0 یا 1 آیتم است: این نحو نکات ظریفی دارد که باید رعایت شوند. تاپل‌های خالی با یک جفت پرانتز خالی ساخته می‌شوند؛ یک تاپل با یک آیتم از طریق دنبال کردن یک مقدار با یک کاما ساخته می‌شود (قرار دادن یک مقدار منفرد در پرانتز کافی نیست). این روش شاید نامتعارف باشد، اما مؤثر است. برای مثال:


``` python
>>> empty = ()
>>> singleton = 'hello',    # <-- note trailing comma
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
```

عبارت `t = 12345, 54321, 'hello!'` نمونه‌ای از **بسته‌بندی تاپل** (tuple packing) است: مقادیر `12345`، `54321` و `'hello!'` در یک تاپل با هم بسته‌بندی شده‌اند. **عملیات معکوس** نیز ممکن است:
``` python
>>> x, y, z = t
```

این عملیات به‌درستی **باز کردن توالی (sequence unpacking)** نامیده می‌شود و برای هر توالی در سمت راست عملگر تساوی قابل استفاده است. در باز کردن توالی، تعداد متغیرها در سمت چپ علامت مساوی باید برابر با تعداد عناصر توالی در سمت راست باشد. دقت کنید که **اختصاص چندگانه** در واقع ترکیبی از بسته‌بندی تاپل و باز کردن توالی است.

## 5.4 مجموعه‌ها (Sets)

پایتون همچنین یک نوع داده برای **مجموعه‌ها (sets)** دارد. مجموعه، یک گردآوری بدون ترتیب است که هیچ عنصر تکراری ندارد. کاربردهای اصلی مجموعه‌ها شامل **آزمایش عضویت** و **حذف ورودی‌های تکراری** است. اشیاء مجموعه همچنین از عملیات ریاضیاتی مانند **اجتماع**، **اشتراک**، **تفاضل** و **تفاضل متقارن** پشتیبانی می‌کنند.

برای ایجاد مجموعه‌ها می‌توان از آکولاد `{ }` یا تابع [set()](https://docs.python.org/3/library/stdtypes.html#set) استفاده کرد. توجه: برای ایجاد یک مجموعه خالی باید از `set()` استفاده کنید، نه `{}`؛ چرا که `{}` یک **دیکشنری خالی** ایجاد می‌کند، که در بخش بعدی به آن خواهیم پرداخت.

در اینجا یک نمایش مختصر آورده شده است:

``` python
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # fast membership testing
True
>>>'crabgrass' in basket
False

>>> # Demonstrate set operations on unique letters from two words
>>>
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b                              # letters in a or b or both
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # letters in both a and b
{'a', 'c'}
>>> a ^ b                              # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
```

به‌طور مشابه با **درک لیست‌ها** ([list comprehensions](https://docs.python.org/3/tutorial/datastructures.html#tut-listcomps))، **درک مجموعه‌ها** (set comprehensions) نیز راحت تر می‌شود:

``` python
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```

## 5.5 دیکشنری‌ها

نوع داده مفید دیگری که در پایتون به‌طور داخلی پشتیبانی می‌شود، **دیکشنری** (dictionary) است (به [**انواع نگاشتی** — `dict`](https://docs.python.org/3/library/stdtypes.html#typesmapping) مراجعه کنید). در زبان‌های دیگر، دیکشنری‌ها گاهی به نام‌های «حافظه‌های وابسته» یا «آرایه‌های وابسته» شناخته می‌شوند. برخلاف توالی‌ها که با یک بازه از اعداد اندیس‌گذاری می‌شوند، دیکشنری‌ها با **کلیدها** اندیس‌گذاری می‌شوند، که می‌توانند هر نوع تغییرناپذیر (immutable) باشند؛ رشته‌ها و اعداد همیشه می‌توانند به‌عنوان کلید استفاده شوند. تاپل‌ها را می‌توان به‌عنوان کلید به‌کار برد اگر فقط شامل رشته‌ها، اعداد یا تاپل‌های دیگر باشند؛ اگر یک تاپل به‌طور مستقیم یا غیرمستقیم حاوی یک شیء قابل تغییر باشد، نمی‌توان از آن به‌عنوان کلید استفاده کرد. از لیست‌ها نمی‌توان به‌عنوان کلید استفاده کرد، چرا که لیست‌ها با استفاده از انتساب اندیس، برش و متدهایی مانند `append()` و `extend()` قابل تغییر هستند.

بهترین راه برای درک یک دیکشنری این است که آن را به‌عنوان مجموعه‌ای از **زوج‌های کلید: مقدار** در نظر بگیریم، با این شرط که کلیدها در یک دیکشنری **یکتا** هستند. یک جفت آکولاد خالی `{}` یک دیکشنری خالی ایجاد می‌کند. قراردادن لیستی از زوج‌های کلید: مقدار درون آکولادها، زوج‌های اولیه‌ی کلید: مقدار را به دیکشنری اضافه می‌کند؛ این همچنین روش نوشتن دیکشنری‌ها در خروجی نیز هست.

عملیات اصلی روی یک دیکشنری شامل **ذخیره‌سازی یک مقدار با استفاده از یک کلید** و **بازیابی مقدار با داشتن کلید** است. همچنین امکان حذف یک زوج کلید: مقدار با استفاده از `del` وجود دارد. اگر با یک کلید که قبلاً استفاده شده ذخیره‌سازی کنید، مقدار قدیمی مرتبط با آن کلید از بین می‌رود. تلاش برای بازیابی یک مقدار با استفاده از کلیدی که وجود ندارد، باعث خطا می‌شود.

عمل `list(d)` روی یک دیکشنری، لیستی از تمام کلیدهای موجود در دیکشنری را به ترتیب درج برمی‌گرداند (اگر می‌خواهید مرتب‌شده باشد، از `sorted(d)` استفاده کنید). برای بررسی اینکه آیا یک کلید خاص در دیکشنری وجود دارد، از **کلیدواژه `in`** استفاده کنید.

در اینجا یک مثال کوچک با استفاده از دیکشنری آورده شده است:

``` python
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
>>> list(tel)
['jack', 'guido', 'irv']
>>> sorted(tel)
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
```

سازنده‌ی [dict()](https://docs.python.org/3/library/stdtypes.html#dict) دیکشنری‌ها را مستقیماً از دنباله‌ای از زوج‌های **کلید-مقدار** می‌سازد:

``` python
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```

علاوه بر این، از **درک دیکشنری**‌ها (dict comprehensions) می‌توان برای ایجاد دیکشنری‌ها از عبارات دلخواه کلید و مقدار استفاده کرد:

``` python
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```

هنگامی که کلیدها رشته‌های ساده هستند، گاهی اوقات مشخص‌کردن زوج‌ها با استفاده از **آرگومان‌های کلیدی** (keyword arguments) آسان‌تر است:

``` python
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```

## 5.6. تکنیک‌های حلقه‌زنی

هنگام پیمایش در دیکشنری‌ها، می‌توان **کلید** و **مقدار متناظر** را به‌طور هم‌زمان با استفاده از متد [items()](https://docs.python.org/3/library/stdtypes.html#dict.items) بازیابی کرد.

``` python
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
```

هنگام پیمایش در یک دنباله، می‌توان **اندیس موقعیت** و **مقدار متناظر** را به‌طور هم‌زمان با استفاده از تابع [enumerate()](https://docs.python.org/3/library/functions.html#enumerate) بازیابی کرد.

``` python
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
```

برای پیمایش هم‌زمان در دو یا چند دنباله، می‌توان ورودی‌ها را با استفاده از تابع [zip()](https://docs.python.org/3/library/functions.html#zip) جفت کرد.

``` python
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...    print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
```

برای پیمایش در یک دنباله به‌صورت معکوس، ابتدا دنباله را در جهت عادی مشخص کرده و سپس از تابع [reversed()](https://docs.python.org/3/library/functions.html#reversed) استفاده کنید.

``` python
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
```

برای پیمایش در یک دنباله به ترتیب مرتب‌شده، از تابع [sorted()](https://docs.python.org/3/library/functions.html#sorted) استفاده کنید که یک لیست مرتب جدید برمی‌گرداند و منبع اصلی را بدون تغییر باقی می‌گذارد.

``` python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for i in sorted(basket):
...    print(i)
...
apple
apple
banana
orange
orange
pear
```

استفاده از [set()](https://docs.python.org/3/library/stdtypes.html#set) روی یک دنباله، عناصر تکراری را حذف می‌کند. استفاده ترکیبی از [sorted()](https://docs.python.org/3/library/functions.html#sorted) و [set()](https://docs.python.org/3/library/stdtypes.html#set) روی یک دنباله، یک روش ایده‌آل برای پیمایش بر روی عناصر یکتای دنباله به ترتیب مرتب‌شده است.

``` python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...    print(f)
...
apple
banana
orange
pear
```

گاهی وسوسه‌انگیز است که در حین پیمایش بر روی یک لیست، آن را تغییر دهید؛ اما اغلب ایجاد یک لیست جدید ساده‌تر و ایمن‌تر است.

``` python
>>> import math
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
```

## 5.7. اطلاعات بیشتر در مورد شرایط

شرایط استفاده شده در عبارات **while** و **if** می‌تواند شامل هر نوع عملیاتی باشد، نه فقط مقایسه‌ها.

عملیات مقایسه **in** و **not in** آزمایش‌های عضویت هستند که تعیین می‌کنند آیا یک مقدار در (یا خارج از) یک مجموعه وجود دارد. عملگرهای **is** و **is not** مقایسه می‌کنند که آیا دو شیء واقعاً همان شیء هستند یا خیر. تمام عملگرهای مقایسه اولویت یکسانی دارند که از اولویت کمتری نسبت به تمام عملگرهای عددی برخوردار است.

مقایسه‌ها می‌توانند به صورت زنجیره‌ای انجام شوند. به عنوان مثال، `a < b == c` بررسی می‌کند که آیا `a` کمتر از `b` است و علاوه بر این، `b` برابر با `c` است.

مقایسه‌ها می‌توانند با استفاده از عملگرهای **Boolean** **and** و **or** ترکیب شوند، و نتیجه یک مقایسه (یا هر عبارت Boolean دیگر) می‌تواند با **not** منفی شود. این عملگرها اولویت کمتری نسبت به عملگرهای مقایسه دارند؛ در میان آن‌ها، **not** بالاترین اولویت و **or** پایین‌ترین را دارد، به‌طوری‌که `A and not B or C` معادل با `(A and (not B)) or C` است. همان‌طور که همیشه، می‌توان از پرانتزها برای بیان ترکیب دلخواه استفاده کرد.

عملگرهای **Boolean** **and** و **or** به عنوان **عملگرهای کوتاه‌مدت** (short-circuit operators) شناخته می‌شوند: آرگومان‌های آن‌ها از چپ به راست ارزیابی می‌شوند و ارزیابی به محض تعیین نتیجه متوقف می‌شود. به عنوان مثال، اگر `A` و `C` درست باشند اما `B` نادرست باشد، `A and B and C` عبارت `C` را ارزیابی نمی‌کند. هنگامی که به عنوان یک مقدار عمومی و نه به عنوان یک Boolean استفاده می‌شود، مقدار بازگشتی یک عملگر کوتاه‌مدت، آخرین آرگومان ارزیابی‌شده است.

امکان اختصاص نتیجه یک مقایسه یا دیگر عبارات Boolean به یک متغیر وجود دارد. برای مثال:
``` python
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
```

توجه داشته باشید که در پایتون، برخلاف C، اختصاص مقدار درون عبارات باید به‌طور صریح با استفاده از **[عملگر والروس](https://docs.python.org/3/faq/design.html#why-can-t-i-use-an-assignment-in-an-expression)** `:=` انجام شود. این امر از بروز یک کلاس رایج از مشکلاتی که در برنامه‌های C پیش می‌آید جلوگیری می‌کند: وارد کردن `=` در یک عبارت در حالی که منظور استفاده از `==` بوده است.

## 5.8. مقایسه دنباله‌ها و سایر انواع

اشیاء دنباله‌ای معمولاً می‌توانند با سایر اشیاء از همان نوع دنباله مقایسه شوند. این مقایسه از **ترتیب لکسیکوگرافی** (lexicographical ordering) استفاده می‌کند: ابتدا دو عنصر اول مقایسه می‌شوند و اگر متفاوت باشند، نتیجه مقایسه تعیین می‌شود؛ اگر برابر باشند، دو عنصر بعدی مقایسه می‌شوند و به همین ترتیب ادامه می‌یابد تا یکی از دنباله‌ها تمام شود. اگر دو عنصر که باید مقایسه شوند خود دنباله‌هایی از همان نوع باشند، مقایسه لکسیکوگرافی به‌صورت بازگشتی انجام می‌شود. اگر تمام عناصر دو دنباله برابر باشند، دنباله‌ها برابر در نظر گرفته می‌شوند. اگر یکی از دنباله‌ها زیر دنباله اولیه دیگری باشد، دنباله کوتاه‌تر به‌عنوان دنباله کوچکتر (lesser) در نظر گرفته می‌شود. ترتیب لکسیکوگرافی برای رشته‌ها از شماره نقطه کد **یونی‌کد** (Unicode) برای مرتب‌سازی کاراکترهای فردی استفاده می‌کند. 

در اینجا چند مثال از مقایسه‌ها بین دنباله‌هایی از همان نوع آورده شده است:

``` python
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
```

توجه داشته باشید که مقایسه اشیاء از انواع مختلف با استفاده از عملگرهای `<` یا `>` قانونی است، مشروط بر اینکه اشیاء دارای متدهای مقایسه مناسب باشند. به عنوان مثال، انواع عددی مختلط بر اساس **مقدار عددی** خود مقایسه می‌شوند، به طوری که `0` با `0.0` برابر است و غیره. در غیر این صورت، به جای ارائه یک ترتیب دلخواه، مفسر یک **استثنای [TypeError](https://docs.python.org/3/library/exceptions.html#TypeError)** ایجاد خواهد کرد.

### پانویس

[^1]: زبان‌های دیگر ممکن است شیء تغییر یافته را بازگردانند، که این امکان را برای **زنجیره‌سازی متدها** (method chaining) فراهم می‌کند، مانند `d->insert("a")->remove("b")->sort();`.
